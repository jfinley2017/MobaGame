// Copyright (C) 2019 Kevin Ossia, Joe Finley, and Nicholas Arthur. Unauthorized copying of this file via any medium is strictly prohibited. 

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "AgoraGameplayAbility.h"
#include "AgoraItem.h"
#include "NoExportTypes.h"
#include "AgoraInventoryComponent.generated.h"

/**
 * Notes:
 *
 * Items consist of:
 * - Attribute changes
 * - Item-Unique effects (If I have two of the same item I only get the benefit once)
 * - Effect-Unique effects (If I have two of the same effect, I only get the benefit once)
 *
 *
 *
 * Addition:
 * - Add static attributes
 * - 
 * - 
 *
 *
 *
 */

class UTexture2D;

USTRUCT(BlueprintType)
struct FAgoraActiveUniqueEffect
{

    GENERATED_BODY()

    FAgoraActiveUniqueEffect() {};

    FAgoraActiveUniqueEffect(FGameplayTag InEffectTag, FActiveGameplayEffectHandle InActiveEffectHandle) :
        EffectTag(InEffectTag),
        ActiveEffectHandle(InActiveEffectHandle) {};

    UPROPERTY()
    FGameplayTag EffectTag;

    UPROPERTY()
    FActiveGameplayEffectHandle ActiveEffectHandle;

};


/**
 * Represents an equipped item. If there are two of the same equipped items in an inventory, there will be two distinct
 * structs representing them. 
 * Maintains any state about the effects an item may have applied.
 */
USTRUCT(BlueprintType)
struct FAgoraActiveItem
{
    GENERATED_BODY()
   
    /** Effectively the CDO of the item. Generated by the asset manager */
    UPROPERTY(BlueprintReadOnly, Category = "AgoraItem")
    const UAgoraItem* Item = nullptr;

    UPROPERTY(BlueprintReadOnly, Category = "AgoraItem")
    FGuid UniqueItemID;

    UPROPERTY(BlueprintReadOnly, Category = "AgoraItem")
    TArray<FActiveGameplayEffectHandle> ActiveEffects;

    UPROPERTY(BlueprintReadOnly, Category = "AgoraItem")
    TArray<FAgoraActiveUniqueEffect> ActiveUniqueEffects;

    UPROPERTY(BlueprintReadOnly, Category = "AgoraItem")
    FGameplayAbilitySpecHandle ActiveAbility;

    bool IsValid() { return Item != nullptr; }

};

/**
 * Represents a single slot in the inventory. Gives us a chance to visualize the slot and maintain state like InputID.
 */
USTRUCT(BlueprintType)
struct FAgoraInventorySlot
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadOnly, Category = "AgoraItem")
    int32 SlotID;

    UPROPERTY(BlueprintReadOnly, Category = "AgoraItem")
    FAgoraActiveItem SlottedItem;

    bool IsEmpty() { return !SlottedItem.IsValid(); }
    UTexture2D* GetItemIcon();

};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemSlotUpdatedSignature, const FAgoraInventorySlot&, ItemSlot);
DECLARE_DELEGATE_OneParam(FUseInventorySlot, int32);

/**
 * Manages items for an owning actor
 */
UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class AGORA_API UAgoraInventoryComponent : public UActorComponent
{
	GENERATED_BODY()

public:	

	// Sets default values for this component's properties
	UAgoraInventoryComponent();

    // UActorComponent interface
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
    // ~UActorComponent interface

    UPROPERTY(BlueprintAssignable, Category = "AgoraInventoryComponent")
    FOnItemSlotUpdatedSignature OnItemSlotUpdated;

    /**
     * Tries to buy an item at the first slot available. Returns true if successful.
     * Returning true in this state does not mean that the item was actually equipped, we are still pending server approval.
     * However a false return is always correct and will go no further
     */
    UFUNCTION(BlueprintCallable, Category = "AgoraInventoryComponent")
    bool TryBuyItem(UAgoraItem* Item);

    /**
     * Tries to sell an item at the specified slot. Returns true if successful.
     * Returning true in this state does not mean that the item at the slot was actually sold, we are still pending server approval.
     * However a false return is always correct and will go no further.
     */
    UFUNCTION(BlueprintCallable, Category = "AgoraInventoryComponent")
    bool TrySellItem(int32 SlotToSellAt);

    /**
     * Equips an item, finding the first unused item slot. Cannot be ran by clients.
     */
    UFUNCTION(BlueprintCallable, Category = "AgoraInventoryComponent")
    void EquipItem(UAgoraItem* Item, int32 Count);

    /**
     * Equips an item at the specified slot. Cannot be ran by clients.
     */
    UFUNCTION()
    void EquipItemAtSlot(UAgoraItem* Item, int32 Count, int32 Slot);

    /**
     * Removes the first item found that matches @Item. Cannot be ran by clients.
     */
    UFUNCTION(BlueprintCallable, Category = "AgoraInventoryComponent")
    void RemoveItem(UAgoraItem* Item, int32 Count);

    /**
     * Removes an item at the specified slot. Cannot be ran by clients.
     */
    UFUNCTION()
    void RemoveItemAtSlot(int32 Count, int32 Slot);

    /**
     * Places the slot found at index @SlotIndex in @OutSlot. Returns false if the index is invalid (out of bounds). 
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventory")
    bool GetInventorySlotAt(int32 SlotIndex, FAgoraInventorySlot& OutSlot);

    /**
     * Generates a debug string, sets OutDebugString to "" prior to appending debug string.
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventory")
    void GenerateDebugString(FString& OutDebugString);

    /**
     * Returns all inventory slots.
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventory")
    void GetAllInventorySlots(TArray<FAgoraInventorySlot>& Slots);

    /**
     * Returns the cost of the item @Item.
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventory")
    float CalculateItemCost(UAgoraItem* Item);

    /**
     * Returns the selling price of @Item. This is usually the price of the item, reduced by some modifier.
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventoryComponent")
    float GetItemSellPrice(const UAgoraItem* Item);

    /**
     * Returns true if this component can purchase the item.
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventoryComponent")
    bool CanPurchaseItem(UAgoraItem* Item);

    /**
     * Returns true if this component can sell the item at the specified slot. False if the slot is empty.
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventoryComponent")
    bool CanSellAtInventorySlot(int32 SlotID);

    /**
     * Returns the current price of the item at the specified slot.
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventoryComponent")
    float GetItemPriceAtInventorySlot(int32 SlotID);

    /**
     * 
     */
    UFUNCTION(BlueprintPure, Category = "AgoraInventoryComponent")
    int32 GetItemCount(const UAgoraItem* Item);

    UFUNCTION()
    void TryUseInventorySlot(int32 Idx);

    UFUNCTION()
    void SetupInventoryInput(UInputComponent* InputComponent);

protected:

    // UAgoraComponent interface
    virtual void BeginPlay() override;
    
    // ~UActorComponent interface

    UFUNCTION(Server, Reliable, WithValidation)
    void Server_TryBuyItem(UAgoraItem* Item);
        
    UFUNCTION(Server, Reliable, WithValidation)
    void Server_TrySellItem(int32 SlotToSellAt);

    /**
     * Finds a slot that contains the designated item, also placing the found slot in @OutItemSlot. Returns -1 if no slot was found.
     */
    UFUNCTION()
    int32 FindSlotFromItem(const UAgoraItem* Item, FAgoraInventorySlot& OutItemSlot);
    
    /**
     * Returns true if we have room for the item in our inventory
     */
    UFUNCTION()
    bool HasRoomForItem(const UAgoraItem* Item);

    /**
     * Finds the first empty slot, placing the index in @EmptySlot
     */
    UFUNCTION()
    bool FindEmptySlot(int32& OutEmptySlot);

    /**
     * Converts an FAgoraItemAttributeModifier to an FGameplayModifierInfo.
     */
    void MakeGameplayModifierInfoFromItemMod(const FAgoraItemAttributeModifier& ItemMod, FGameplayModifierInfo& OutGameplayModInfo);

    /**
     * Converts an FAgoraItemAttributeModifier to an FGameplayModifierInfo which negates the modifiers in the FAgoraItemAttributeModifier.
     */
    void MakeNegationGameplayModifierInfoFromItemMod(const FAgoraItemAttributeModifier& ItemMod, FGameplayModifierInfo& OutGameplayModInfo);

    /**
     * Determines if an item is providing the specified unique effect for
     */
    bool IsProviderOfUniqueEffect(const FAgoraActiveItem& Item, FGameplayTag UniqueEffectIdentifier);

    void RegenerateInventoryEffectsPostItemRemoval();

    int32 NumInventorySlots = 6;
    int32 NumActivateableSlots = 6;

    UPROPERTY(EditAnywhere, ReplicatedUsing = OnRep_Inventory, BlueprintReadOnly, Category = "Inventory")
    TArray<FAgoraInventorySlot> Inventory;

    TMap<FGameplayTag, FAgoraActiveItem> UniqueProviders;
    TMap<TSubclassOf<UAgoraGameplayAbility>, FAgoraActiveItem> AbilityProvider;


    UFUNCTION()
    virtual void OnRep_Inventory();

};
